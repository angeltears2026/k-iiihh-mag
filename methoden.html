<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>methoden - k-iiiihh mag vol.01</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- Navigation Bar -->
  <nav class="top-nav">
    <div class="nav-container">
      <!-- LOGO LEFT -->
      <a href="index.html" class="nav-logo">k-iiiihh mag vol.01 — 2026 ★</a>
      
      <!-- NAV MENU TOGGLE -->
      <button class="nav-menu-toggle" id="navMenuToggle">+</button>
      <ul class="nav-links" id="navLinks" style="display: none;">
        <li><a href="about.html">about</a></li>
        <li><a href="qa.html">q&a</a></li>
        <li><a href="galerie.html">galerie</a></li>
        <li><a href="methoden.html">methoden</a></li>
      </ul>
    </div>
  </nav>

  <!-- Methods Guide Section -->
  <section id="methods" class="methods subpage-hero">
    <div class="container">
      <h2>methoden</h2>
      <div class="floating-methods" id="floatingMethods">
        <!-- Method 1 -->
        <div class="method-item floating-method-item">
          <button class="method-question-text" aria-expanded="false">skizzieren</button>
          <div class="method-answer">
            <p>
              ki kann man wie eine schnelle ideenskizze nutzen. du beschreibst kurz, woran du arbeitest, und schaust dir mehrere varianten an. das ziel ist nicht, eines dieser bilder zu übernehmen, sondern impulse zu bekommen: andere lichtstimmungen, andere perspektiven, andere kompositionen.
            </p>
          </div>
        </div>

        <!-- Method 2 -->
        <div class="method-item floating-method-item">
          <button class="method-question-text" aria-expanded="false">entlasten</button>
          <div class="method-answer">
            <p>
              ki ist besonders nützlich für aufgaben, die technisch oder repetitiv sind und dich vom eigentlichen arbeiten abhalten. dazu gehören zum beispiel das aufräumen von bildern, das entfernen störender elemente, das testen von farben oder das sortieren deines archivs.
            </p>
            <p>
              die inhaltlichen und künstlerischen entscheidungen triffst weiterhin du.
            </p>
            <p>
              eine einfache orientierung dabei ist:
            </p>
            <p>
              alles, was mit gefühl, konzept oder ausdruck zu tun hat, bleibt menschlich.
            </p>
            <p>
              alles, was rein technisch ist, kann ki unterstützen.
            </p>
            <p>
              so gewinnt man zeit für das wesentliche, ohne den eigenen stil aus der hand zu geben.
            </p>
          </div>
        </div>

        <!-- Method 3 -->
        <div class="method-item floating-method-item">
          <button class="method-question-text" aria-expanded="false">einordnen</button>
          <div class="method-answer">
            <p>
              ki lässt sich auch als informations- und reflexionshilfe nutzen, ohne dass sie direkt in das werk eingreift. du kannst sie nach bedeutungen von farben, symbolen oder bildtraditionen fragen und dir anregungen geben lassen.
            </p>
            <p>
              diese antworten sind keine wahrheit, sondern material zum weiterdenken. du prüfst, was für dich sinnvoll ist, und entwickelst deine eigenen ideen daraus weiter.
            </p>
          </div>
        </div>

        <!-- Method 4 -->
        <div class="method-item floating-method-item">
          <button class="method-question-text" aria-expanded="false">vermischen</button>
          <div class="method-answer">
            <p>
              ki-tools lassen sich nutzen, um bestehende fotos, videos, malereien oder zeichnungen digital zu verfremden, zu animieren oder zu bearbeiten. sogenanntes mixed media generating. wenn du eine analoge zeichnung gemacht hast, kannst du sie animieren oder in verschiedenen stilen verfremden lassen. das ursprüngliche werk bleibt von dir, die digitale ebene wird durch ki ergänzt.
            </p>
            <p>
              die basis kommt immer von dir, ki erweitert sie um neue möglichkeiten. so verbindest du analoge und digitale arbeitsweisen, ohne die kontrolle über dein werk abzugeben.
            </p>
          </div>
        </div>

        <!-- Method 5 -->
        <div class="method-item floating-method-item">
          <button class="method-question-text" aria-expanded="false">irritieren lassen</button>
          <div class="method-answer">
            <p>
              tools zur bilderzeugung können als experimentelle zufallsverfahren dienen, auf deren basis du weiterarbeitest. du generierst ein bild mit einem ungewöhnlichen prompt – einem gedicht oder song-lyrics. das ergebnis gefällt dir nicht komplett, aber ein detail, eine farbstimmung oder eine form wird zum startpunkt für deine eigene arbeit, analog oder digital.
            </p>
            <p>
              das ziel ist nicht das perfekte ki-bild, sondern ein ausgangspunkt: etwas, das dich inspiriert, irritiert oder in eine neue richtung lenkt. so nutzt du den zufall produktiv, ohne dich vom ergebnis abhängig zu machen.
            </p>
          </div>
        </div>

        <!-- Method 6 -->
        <div class="method-item floating-method-item">
          <button class="method-question-text" aria-expanded="false">im kreis arbeiten</button>
          <div class="method-answer">
            <p>
              du kannst mit der ki in einen dialogischen prozess treten: etwas generieren lassen, selbst verändern, wieder generieren lassen, erneut anpassen. du lässt ein bild generieren, das du analog überarbeitest. das überarbeitete bild wird wieder digital verändert, daraus entsteht musik, daraus ein text, daraus wieder ein neues bild.
            </p>
            <p>
              dieser kreislauf kann mehrfach durchlaufen werden, auch über verschiedene tools hinweg. der prozess selbst kann dokumentiert und zum teil der arbeit werden. so entsteht ein kreativer dialog, bei dem du die richtung bestimmst.
            </p>
          </div>
        </div>
      </div>
    </div>
  </section>

  <script>
    // Store original positions
    const originalPositions = new Map();
    const sidePositions = new Map();
    
    // Floating Methods positioning with collision detection and viewport bounds
    function positionFloatingMethods() {
      const items = document.querySelectorAll('.floating-method-item');
      const positions = [];
      const container = document.getElementById('floatingMethods');
      const containerWidth = container.offsetWidth || window.innerWidth;
      const containerHeight = container.offsetHeight || window.innerHeight;
      
      // Collision detection using percentages (like gallery)
      function checkCollision(newTopPercent, newLeftPercent, positions, itemWidth = 400, itemHeight = 250, padding = 30) {
        const itemWidthPercent = (itemWidth / containerWidth) * 100;
        const itemHeightPercent = (itemHeight / containerHeight) * 100;
        const paddingPercent = (padding / containerWidth) * 100;
        
        const newRight = newLeftPercent + itemWidthPercent;
        const newBottom = newTopPercent + itemHeightPercent;
        
        for (let pos of positions) {
          const existingRight = pos.left + pos.widthPercent;
          const existingBottom = pos.top + pos.heightPercent;
          
          if (!(newRight + paddingPercent < pos.left || 
                newLeftPercent > existingRight + paddingPercent || 
                newBottom + paddingPercent < pos.top || 
                newTopPercent > existingBottom + paddingPercent)) {
            return true; // Collision detected
          }
        }
        return false; // No collision
      }
      
      // Find safe position
      function findSafePosition(positions, itemWidth, itemHeight, maxAttempts = 300) {
        for (let attempt = 0; attempt < maxAttempts; attempt++) {
          const topPercent = Math.random() * 70;
          const leftPercent = 5 + Math.random() * 80;  // 5% bis 85%, mit Abstand zu den Rändern
          
          if (!checkCollision(topPercent, leftPercent, positions, itemWidth, itemHeight, 30)) {
            return { topPercent, leftPercent };
          }
        }
        return null;
      }
      
      items.forEach((item, index) => {
        const itemWidth = item.offsetWidth || 400;
        const itemHeight = item.offsetHeight || 250;
        const itemWidthPercent = (itemWidth / containerWidth) * 100;
        const itemHeightPercent = (itemHeight / containerHeight) * 100;
        
        const pos = findSafePosition(positions, itemWidth, itemHeight);
        if (pos) {
          positions.push({ 
            top: pos.topPercent, 
            left: pos.leftPercent, 
            widthPercent: itemWidthPercent, 
            heightPercent: itemHeightPercent
          });
          originalPositions.set(item, pos);
          
          item.style.position = 'absolute';
          item.style.left = pos.leftPercent + '%';
          item.style.top = pos.topPercent + '%';
          item.style.zIndex = 10;
        }
      });
    }
    
    // Calculate side positions for other items
    function calculateSidePositions(activeItem) {
      const items = document.querySelectorAll('.floating-method-item');
      const activeIndex = Array.from(items).indexOf(activeItem);
      const itemWidth = activeItem.offsetWidth || 300;
      const itemHeight = activeItem.offsetHeight || 150;
      const padding = 60;
      const topPadding = 60;
      
      let sideIndex = 0;
      items.forEach((item, index) => {
        if (item === activeItem) return;
        
        // Alternate left and right sides
        if (sideIndex % 2 === 0) {
          // Left side
          const sideX = padding;
          const sideY = Math.max(topPadding, topPadding + (sideIndex * 100));
          sidePositions.set(item, { x: sideX, y: sideY });
        } else {
          // Right side
          const sideX = Math.max(padding, window.innerWidth - (item.offsetWidth || 300) - padding);
          const sideY = Math.max(topPadding, topPadding + ((sideIndex - 1) * 100));
          sidePositions.set(item, { x: sideX, y: sideY });
        }
        sideIndex++;
      });
    }
    
    // Method Toggle Functionality with Center Animation
    document.querySelectorAll('.method-question-text').forEach(button => {
      button.addEventListener('click', function() {
        const methodItem = this.closest('.floating-method-item');
        const isOpen = this.getAttribute('aria-expanded') === 'true';
        const items = document.querySelectorAll('.floating-method-item');
        
        // Check if another item is open
        const anotherItemOpen = Array.from(items).some(item => {
          const btn = item.querySelector('.method-question-text');
          return btn && btn !== this && btn.getAttribute('aria-expanded') === 'true';
        });
        
        if (!isOpen) {
          // Opening: move item to center and others to sides
          // First, reset any previously opened item
          if (anotherItemOpen) {
            items.forEach(item => {
              const btn = item.querySelector('.method-question-text');
              if (btn && btn.getAttribute('aria-expanded') === 'true') {
                btn.setAttribute('aria-expanded', 'false');
              }
            });
          }
          
          this.setAttribute('aria-expanded', 'true');
          
          // Close other items and move them to sides
          calculateSidePositions(methodItem);
          
          items.forEach(item => {
            if (item === methodItem) {
              // Animate active item to center
              const itemWidth = item.offsetWidth;
              const itemHeight = item.offsetHeight;
              const targetX = (window.innerWidth - itemWidth) / 2;
              const targetY = 30;
              
              item.style.transition = 'all 0.6s ease-out';
              item.style.left = targetX + 'px';
              item.style.top = targetY + 'px';
              item.style.zIndex = 100;
              item.style.transform = 'scale(1)';
            } else {
              // Move other items to sides and make them smaller
              const otherButton = item.querySelector('.method-question-text');
              if (otherButton) {
                otherButton.setAttribute('aria-expanded', 'false');
              }
              
              if (sidePositions.has(item)) {
                const sidePos = sidePositions.get(item);
                item.style.transition = 'all 0.6s ease-out';
                item.style.left = sidePos.x + 'px';
                item.style.top = sidePos.y + 'px';
                item.style.zIndex = 5;
                item.style.transform = 'scale(0.7)';
              }
            }
          });
        } else {
          // Closing: return all items to original positions
          this.setAttribute('aria-expanded', 'false');
          
          items.forEach(item => {
            if (originalPositions.has(item)) {
              const origPos = originalPositions.get(item);
              item.style.transition = 'all 0.6s ease-out';
              item.style.left = origPos.leftPercent + '%';
              item.style.top = origPos.topPercent + '%';
              item.style.zIndex = 10;
              item.style.transform = 'scale(1)';
            }
          });
          
          // Clear side positions
          sidePositions.clear();
        }
      });
    });
    
    // Position floating methods on load
    window.addEventListener('load', positionFloatingMethods);
    positionFloatingMethods();
    
    // Navigation menu positioning and toggle
    const navMenuToggle = document.getElementById('navMenuToggle');
    const navLinks = document.getElementById('navLinks');
    
    function positionNavMenu() {
      if (!navMenuToggle || !navLinks) return;
      
      const toggleRect = navMenuToggle.getBoundingClientRect();
      const linksWidth = navLinks.offsetWidth;
      const gap = 24; // 1.5rem in pixels (aus .nav-links a padding)
      
      // Position: button right edge - links width - gap
      const rightPosition = window.innerWidth - toggleRect.right + gap;
      navLinks.style.right = rightPosition + 'px';
    }
    
    if (navMenuToggle && navLinks) {
      navMenuToggle.addEventListener('click', function(e) {
        e.preventDefault();
        const isVisible = navLinks.style.display === 'block';
        navLinks.style.display = isVisible ? 'none' : 'block';
        navMenuToggle.classList.toggle('active');
        navMenuToggle.textContent = isVisible ? '+' : '|';
        
        // Position menu after showing
        if (!isVisible) {
          setTimeout(positionNavMenu, 0);
        }
      });
      
      // Position on load and resize
      window.addEventListener('load', positionNavMenu);
      window.addEventListener('resize', positionNavMenu);
    }
  </script>
</body>
</html>
